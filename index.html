<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document</title>
</head>

<body>
  <div id="container"></div>
  <script src="d3.v6.min.js"></script>
  <script type="text/javascript" src="stardust.bundle.min.js"></script>
  <script src="stardustutils.js" type="text/javascript"></script>
  <script src="tfdp.js" type="text/javascript"></script>
  <div class="sliders"></div>
  <canvas id="main-canvas"></canvas>

  <div class="initializing">
    <p>Initializing...</p>
  </div>
  <style type="text/css">
    .fps {
      position: fixed;
      top: 0;
      right: 0;
      padding: 10px;
      margin: 0;
      font-size: 15px;
    }

    .sliders {
      /* position: absolute; */
      left: 0px;
      width: 640px;
      padding-top: 10px;
      bottom: 0;
    }

    .sliders label {
      display: inline-block;
      font-weight: bold;
      white-space: pre;
      /* width: 620px; */
    }

    .sliders input {
      display: inline-block;
      /* width: 100%; */
      margin: 5px 0;
    }

    .sliders input[type=number] {
      display: inline-block;
      width: 50px;
      margin: 5px 0;
    }
  </style>
  <script>
    const width = 800;
    const height = 800;
    var data = [];
    var nodes = [];
    var links = [];

    var timer = d3.timer;
    var cnt = 0;

    var maxiter = 600;
    var K = 1.0,
      p = 2.0,
      yScaleFactorAttr = 1.0,
      xScaleFactorAttr = 1.0,
      DegreeAttr = 1.0;
    var yScaleFactorRep = 1.0,
      xScaleFactorRep = 1.0,
      DegreeRep = 1.5;

    var renderScale = 1.0;

    var repulforce = tfdp().strength(-1);
    var stepper1;
    var iter = 0;
    var alpha = 0.5;
    // function sleep(d) {
    //     for (var t = Date.now(); Date.now() - t <= d;);
    //   }
    // function step() {
    //   cnt += 1;
    //   console.log('c', cnt);
    //   if (cnt > 100) {
    //     stepper1.stop();
    //   }
    // };

    //  = timer(step);




    var canvas = document.getElementById("main-canvas");
    var platform = Stardust.platform("webgl-2d", canvas, width, height);
    var snodes = Stardust.mark.create(Stardust.mark.circle(10), platform);
    var sedges = Stardust.mark.create(Stardust.mark.line(), platform);
    var positions;

    function makeSlider(name, attr, min, max, defaultValue) {

      var slider = d3.select(".sliders").append("input");
      slider
        // .attr("id", "range" + attr)
        .attr("type", "range")
        .attr("min", 0)
        .attr("max", 10000)
        .attr("value", ((defaultValue - min) / (max - min)) * 10000);
      var val = +slider.property("value");
      var d = (val / 10000) * (max - min) + min;
      // if (attr == "p" || attr == "c1" || attr == "c2") d = d;
      // else d = Math.pow(10, d);

      var sliderinput = d3.select(".sliders").append("input");
      sliderinput
        // .attr("id", "input" + attr)
        .attr("type", "number")
        .attr("value", d);


      slider.on("input", () => {
        var val = +slider.property("value");
        var d = (val / 10000) * (max - min) + min;
        // if (attr == "p" || attr == "c1" || attr == "c2") d = d;
        // else d = Math.pow(10, d);
        // sliderinput.property("value") = d;
        if (attr == "K") {
          K = d;
          alpha = 0.1;
        }
        if (attr == "p") {
          if (d >= 0.99) p = d;
          else d = 0.99;
          alpha = 0.1;
        }
        if (attr == "a1") {
          yScaleFactorAttr = d;
          alpha = 0.1;
        }
        if (attr == "a2") {
          yScaleFactorRep = d;
          alpha = 0.1;
        }
        if (attr == "c2") {
          DegreeRep = d;
          alpha = 0.1;
        }
        // document.getElementById("input" + attr).property("value") = d;
        document.getElementById("label" + attr).innerHTML = " " + attr + " = " + d.toFixed(3) + ", ";
        // force.alphaTarget(0.3).restart();
      });

      sliderinput.on("input", () => {
        var val = +sliderinput.property("value");

        var d = val;
        // if (attr == "p" || attr == "c1" || attr == "c2") d = d;
        // else d = Math.pow(10, d);
        if (attr == "K") {
          K = d;
          alpha = 0.1;
        }
        if (attr == "p") {
          if (d >= 0.99) p = d;
          else d = 0.99;
          alpha = 0.1;
        }
        if (attr == "a1") {
          yScaleFactorAttr = d;
          alpha = 0.1;
        }
        if (attr == "a2") {
          yScaleFactorRep = d;
          alpha = 0.1;
        }
        if (attr == "c2") {
          DegreeRep = d;
          alpha = 0.1;
        }
        // document.getElementById("range" + attr).property("value") = d;
        document.getElementById("label" + attr).innerHTML = " " + attr + " = " + d.toFixed(3) + ", ";
        // force.alphaTarget(0.3).restart();
      });

      d3.select(".sliders")
        .append("label")
        .attr("id", "label" + attr)
        .text(" " + attr + " = " + d.toFixed(3) + ", ");
      d3.select(".sliders")
        .append("label")
        .text(name);
      d3.select(".sliders")
        .append("br");
    }


    makeSlider("Long Range Attractive Force Ratio", "K", 0, 10, 1);
    makeSlider("Long Range Attractive Force Exponent", "p", 0, 10, 2);
    makeSlider("Short Range Attractive Force Ratio", "a1", 0, 10, 1);
    // makeSlider("Short Range Attractive Force x-axis Scale", "b1", 0, 10, 1);
    // makeSlider("Short Range Attractive Force Degree", "c1", 1, 10, 1);

    makeSlider("Short Range Repulsive Force Ratio", "a2", 0, 10, 1);
    // makeSlider("Short Range Repulsive Force x-axis Scale", "b2", 0, 10, 1);
    makeSlider("Short Range Repulsive Force Degree", "c2", 1, 10, 2);

    d3.text("https://fahaizhong.github.io/data/USPowerGrid.txt_init").then(function (data) {
      var lines = data.split("\n");
      var header = lines[0].split(" ");
      var N = parseInt(header[0]);
      var E = parseInt(header[1]);
      var i = 0;
      // read graph data init by pivotMDS
      for (i = 0; i < N; i++) {
        var temp = lines[i + 1].split(" ");
        nodes.push({ id: i.toString(), x: parseFloat(temp[0]), y: parseFloat(temp[1]), vx: 0.0, vy: 0.0, index: i });
        // nodes.push({ id: i.toString(), x: Math.random() * 10, y: Math.random() * 10, vx: 0.0, vy: 0.0, index: i });

      }


      for (i = 0; i < E; i++) {
        var temp = lines[i + N + 1].split(" ");
        links.push({ source: nodes[parseInt(temp[0])], target: nodes[parseInt(temp[1])] });
      }
      console.log("Initialized");
      snodes.attr("center", (d) => [d.x, d.y]);
      snodes.attr("radius", 1.5);
      snodes.attr("color", [1, 0, 0, 0.8]);
      sedges.attr("p1", (d) => [d.source.x, d.source.y]);
      sedges.attr("p2", (d) => [d.target.x, d.target.y]);
      sedges.attr("color", [192.0 / 256, 192.0 / 256, 192.0 / 256, 0.5]);

      var pos = nodes.map(d => [d.x, d.y]);
      positions = Stardust.array("Vector2")
        .value(d => d)
        .data(pos);
      var positionScale = Stardust.scale.custom("array(pos, value)").attr("pos", "Vector2Array", positions);
      snodes.attr("center", positionScale(d => d.index));
      sedges.attr("p1", positionScale(d => d.source.index));
      sedges.attr("p2", positionScale(d => d.target.index));
      snodes.data(nodes);
      sedges.data(links);


      var xs = nodes.map(d => d.x);
      var ys = nodes.map(d => d.y);
      var minx = d3.min(xs);
      var miny = d3.min(ys);
      var maxx = d3.max(xs);
      var maxy = d3.max(ys);
      var midx = (minx + maxx) / 2;
      var midy = (miny + maxy) / 2;
      renderScale = Math.max(maxy - miny, maxx - minx) * 1.05;
    }).then(Simulation);




    function Simulation() {
      var i = 0;

      repulforce.initialize(nodes);
      stepper1 = timer(step);
      // var seti = setInterval(() => {
      //   SimulationStep(alpha);
      //   // RenderStep();
      //   alpha *= 0.99;
      //   alpha = Math.max(alpha, 0.01);
      //   // console.log(alpha);
      //   i++;
      //   if (i >= maxiter) {
      //     clearInterval(seti);
      //   }
      // }, 5);
      // for (i = 0; i < maxiter; i++) {

      // }

    }

    function step() {
      SimulationStep(alpha);
      alpha *= 0.997;
      alpha = Math.max(alpha, 0.01);
      if (iter >= maxiter) {
        stepper1.stop();
      }
    }
    function render() {
      sedges.render();
      snodes.render();
    }

    function SimulationStep(alpha) {
      var i = 0;
      for (i = 0; i < links.length; i++) {
        var link = links[i], source = link.source, target = link.target;
        var x = source.x - target.x;
        var y = source.y - target.y;
        var l = Math.sqrt(x * x + y * y);
        var r = yScaleFactorAttr / Math.pow((1 + xScaleFactorAttr * l * l), DegreeAttr) + K * Math.pow(l, p - 1);
        source.vx -= x * r;
        source.vy -= y * r;
        target.vx += x * r;
        target.vy += y * r;
      }
      repulforce.xScaleFactor(xScaleFactorRep).yScaleFactor(yScaleFactorRep).Degree(DegreeRep);
      repulforce(1.0);

      for (i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        var mag = Math.sqrt(node.vx * node.vx + node.vy * node.vy);
        var lim = 1.0 / mag * Math.min(1.0, mag);
        node.x += alpha * node.vx * lim;
        node.vx = 0.0;
        node.y += alpha * node.vy * lim;
        node.vy = 0.0;
      }
      var xs = nodes.map(d => d.x);
      var ys = nodes.map(d => d.y);
      var minx = d3.min(xs);
      var miny = d3.min(ys);
      var maxx = d3.max(xs);
      var maxy = d3.max(ys);
      var midx = (minx + maxx) / 2;
      var midy = (miny + maxy) / 2;
      var scale = Math.max(maxy - miny, maxx - minx) * 1.05;
      if (scale > 1.05 * renderScale) renderScale = 1.1 * scale;
      if (scale < renderScale / 1.2) renderScale = scale;
      console.log(renderScale, scale);
      var pos = nodes.map(d => [(d.x - midx) / renderScale * width + width / 2, ((midy - d.y) / renderScale + (maxy - midy) / renderScale - 0.48) * height + height / 2]);
      positions.data(pos);
      requestAnimationFrame(render);
    }

    // function RenderStep() {
    //   var xs = nodes.map(d => d.x);
    //   var ys = nodes.map(d => d.y);
    //   var minx = d3.min(xs);
    //   var miny = d3.min(ys);
    //   var maxx = d3.max(xs);
    //   var maxy = d3.max(ys);
    //   var midx = (minx + maxx) / 2;
    //   var midy = (miny + maxy) / 2;
    //   var scale = Math.max(maxy - miny, maxx - minx);
    //   var pos = nodes.map(d => [(d.x - midx) / scale * width + width / 2, (d.y - midy) / scale * height + height / 2]);
    //   positions.data(pos);
    //   requestAnimationFrame(render);
    // }
  </script>
</body>

</html>